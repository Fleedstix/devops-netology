> Домашнее задание к занятию "6.6. Troubleshooting"

> 1. Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.
Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.
Вы как инженер поддержки решили произвести данную операцию:
напишите список операций, которые вы будете производить для остановки запроса пользователя
предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

Выводим все запросы выполняющиеся больше 5 секунд:
```
use <YOUR-DB>;
db.currentOp().inprog.forEach(
   function(d){
     if(d.secs_running > 5)
        printjson(d)
})
```
убиваем процесс по его opid
```
db.killOp(<opid>)
```
Проблема с долгими запросами решается подключением мониторинга, своевременным масштабированием и оптимизацией "кривых" запросов.

> 2. Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.

>При масштабировании сервиса до N реплик вы увидели, что:
сначала рост отношения записанных значений к истекшим
Redis блокирует операции записи
Как вы думаете, в чем может быть проблема?

Проблема в том что Redis однопоточен, и он не может читать другие команды, пока команда, которая пришла раньше не завершится. Решением данной проблемы является репликация master-slave для отделения записи от чтения. 

> 3. Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:
```
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```
> Как вы думаете, почему это начало происходить и как локализовать проблему?Какие пути решения данной проблемы вы можете предложить?

Данная ошибка может возникать при длительном периоде бездействии при подключении к БД. Вариантом решения данной проблемы может быть изменение времени переподключения к БД на стороне клиента или же увелечением значения wait_timeout в конфиге Mysql.

>4. Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что: postmaster invoked oom-killer. Как вы думаете, что происходит? Как бы вы решили данную проблему? 

Данная ошибка означает что процесс, который работает для защиты ОС от аварийного завершения, завершил процесс сервера postmaster, чтобы спасти ядро ОС от сбоя. Вижу несколько способов решения данной проблемы:
1. понизить оценку процесса сервера PostgreSQL
```
rcctl set <i>servicename</i> oomprotect -1000
```
2. Процесс OOM-Killer можно отключить
3. Задать значение overcommit_memory, для того чтобы ядро не резервировало лищнюю память.
Считаю что перечисленные примеры являются лишь временным решением и самым лучшим решением является увелечение ОЗУ сервера или же диагностика потребляемой процессами пямяти, в следствии возможной оптимизации.